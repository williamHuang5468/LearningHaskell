# Learning Haskell Ch3 - 函數的語法 #

## Pattern matching ##

**檢查我們傳給它的數字是不是 7。**

	lucky :: (Integral a) => a -> String  
	lucky 7 = "LUCKY NUMBER SEVEN!"  
	lucky x = "Sorry, you're out of luck, pal!"

用If辦到判別

	sayMe :: (Integral a) => a -> String  
	sayMe 1 = "One!"  
	sayMe 2 = "Two!"  
	sayMe 3 = "Three!"  
	sayMe 4 = "Four!"  
	sayMe 5 = "Five!"  
	sayMe x = "Not between 1 and 5"

>>Notice:如果`sayMe x = "Not between 1 and 5"`放到前面，就會所有都是`sayMe x = "Not between 1 and 5"`

遞迴Factorial

	factorial :: (Integral a) => a -> a  
	factorial 0 = 1  
	factorial n = n * factorial (n - 1)

如果給3

計算步驟：先計算 `3*factorial 2`，`factorial 2` 等於 `2*factorial 1`，也就是 `3*(2*(factorial 1))`。`factorial 1` 等於 `1*factorial 0`

**失敗的模式匹配**

當你的模式沒有涵蓋到所有情況

	charName :: Char -> String  
	charName 'a' = "Albert"  
	charName 'b' = "Broseph"  
	charName 'c' = "Cecil"

例子中:只要不是a,b,c就會失敗

	ghci> charName 'a'  
	"Albert"  
	ghci> charName 'b'  
	"Broseph"  
	ghci> charName 'h'  
	"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName

**對Tuple的匹配**

**二維空間中的向量相加**

還不瞭解模式匹配的解法

	addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
	addVectors a b = (fst a + fst b, snd a + snd b)

模式匹配的解法

	addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
	addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

`fst` 和 `snd` 可以從序對中取出元素。三元組 (Tripple) 呢？嗯，沒現成的函數，得自己動手：

	first :: (a, b, c) -> a  
	first (x, _, _) = x  
	
	second :: (a, b, c) -> b  
	second (_, y, _) = y  
	
	third :: (a, b, c) -> c  
	third (_, _, z) = z

`_`表示我們不關心具體內容

在List Comprehension使用模式匹配

	ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]  
	ghci> [a+b | (a,b) <- xs]  
	[4,7,6,8,11,4]

對 List 本身也可以使用模式匹配。你可以用 [] 或 : 來匹配它。因為 [1,2,3] 本質就是 1:2:3:[] 的語法糖。你也可以使用前一種形式，像 x:xs 這樣的模式可以將 List 的頭部綁定為 x，尾部綁定為 xs。如果這 List 只有一個元素，那麼 xs 就是一個空 List。

>>*Note*：``x:xs`` 這模式的應用非常廣泛，尤其是遞迴函數。不過它只能匹配長度大於等於 1 的 List。

如果你要把 List 的前三個元素都綁定到變數中，可以使用類似 x:y:z:xs 這樣的形式。它只能匹配長度大於等於 3 的 List。

自行實作`head`變數

	head :: [a] -> a  
	head [] = error "Can't call head on an empty list, dummy!"  
	head (x:_) = x

Run 

	ghci> head' [4,5,6]  
	4  
	ghci> head' "Hello"  
	'H'

>> 若要綁定多個變數(用 `_` 也是如此)，我們必須用括號將其括起

>> `error` 函數，它可以生成一個運行時錯誤，用參數中的字串表示對錯誤的描述。它會直接導致程序崩潰，因此應謹慎使用。

用模式匹配實作`length`

	length' :: (Num b) => [a] -> b  
	length' [] = 0  
	length' (_:xs) = 1 + length' xs

先定義好未知輸入的結果 --- 空 List

在第二個模式中將這 List 分割為頭部和尾部。

List 的長度就是其尾部的長度加 1。匹配頭部用的 _，因為我們並不關心它的值。同時也應明確，我們顧及了 List 所有可能的模式：第一個模式匹配空 List，第二個匹配任意的非空 List。

解釋:

用"ham" 呼叫 length。

首先它會檢查它是否為空 List。顯然不是，於是進入下一模式。

它匹配了第二個模式，把它分割為頭部和尾部並無視掉頭部的值，得長度就是 1+length' "am"。

以此類推，"am" 的 length 就是 1+length' "m"。好，現在我們有了 1+(1+length' "m")。

length' "m" 即 1+length "" (也就是 1+length' [] )。根據定義，length' [] 等於 0。最後得 1+(1+(1+0))。

用模式匹配實作`sum`

	sum' :: (Num a) => [a] -> a  
	sum' [] = 0  
	sum' (x:xs) = x + sum' xs

我們知道空 List 的和是 0，就把它定義為一個模式。我們也知道一個 List 的和就是頭部加上尾部的和的和。

**`as`模式**

將一個名字和 @ 置於模式前，可以在按模式分割什麼東西時仍保留對其整體的引用。

如這個模式 `xs@(x:y:ys)`，它會匹配出與 `x:y:ys` 對應的東西，同時你也可以方便地通過 xs 得到整個 List，而不必在函數體中重複 `x:y:ys`。

	capital :: String -> String  
	capital "" = "Empty string, whoops!"  
	capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]

Run

	ghci> capital "Dracula"  
	"The first letter of Dracula is D"

>>使用 as 模式通常就是為了在較大的模式中保留對整體的引用，從而減少重複性的工作。

>> 你不可以在模式匹配中使用 ++。
>
>>若有個模式是 (xs++ys)，那麼這個 List 該從什麼地方分開呢？不靠譜吧。
>
>>而 (xs++[x,y,z]) 或只一個 (xs++[x]) 或許還能說的過去，不過出於 List 的本質，這樣寫也是不可以的。

## 什麼是 Guards ##